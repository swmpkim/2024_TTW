---
title: "SWMP data exploration"
format: html
editor: visual
toc: true
embed-resources: true
message: false
warning: false
error: true
---

link to this file on github:   

# Setup

```{r}
library(SWMPr)
library(skimr)
library(tidyverse)
library(zoo)  # for as.yearmon
```


At this point in the workshop, we have talked about working directories, projects, and the `here` package. This file is set up to pull data files from the `data` folder in this workshop's directory.

The data used to generate this file are from GNDBHWQ, GNDBHNUT, and GNDCRMET - all stations at Grand Bay.

HOWEVER. The code is written in such a way that, if you put your own data files into the `data` folder, you only have to change the stations in the following code chunk to use your own data.

```{r}
stn_wq <- "gndbhwq"
stn_nut <- "gndbhnut"
stn_met <- "gndcrmet"

data_path <- here::here("data")
```

# Import data

## `SWMPr::import_local()`

The wonderfully easy `SWMPr` way:

```{r}
dat_wq <- import_local(data_path,
                       stn_wq)

# note - when I'm not trying to write flexible code, I 
# use the station name directly; e.g.

# import_local(data_path, "gndbhwq")

dat_nut <- import_local(data_path,
                        stn_nut,
                        collMethd = 1)  # grabs only

dat_met <- import_local(data_path,
                        stn_met)
```

## `read.csv()` and friends

If you're not working with SWMP data, you can use other functions to read in data. `SWMPr` takes care of several things for us, and to demonstrate the difference, we'll look at a single year of nutrient data.

```{r}
bhnut <- read.csv(here::here("data", "gndbhnut2018.csv"))
```

To work with Excel files, check out the `readxl` package's `read_xlsx()` function.

# Investigate the data

We want to know several things once we've read in data - did it read in correctly? Do the values look right? How about column names? What is even in this data frame??

As with most things in R, there are many ways to go about this. Let's examine a few.

## Size, names, first few values

```{r}
dim(dat_nut)  # rows, columns
names(dat_nut)

head(dat_nut)
```

Contrast this with our other nutrient data frame.

```{r}
dim(bhnut)
names(bhnut)

head(bhnut)
```

### Sidebar: janitor::clean_names()

We can easily clean up those names thanks to the `janitor` package.

```{r}
bhnut <- janitor::clean_names(bhnut)
names(bhnut)
```

## Checking column types  

Names are different; values look the same. `SWMPr` automatically removed some columns for us, and put all names into lower case.

Something that's less obvious is what `SWMPr` did to the `datetimestamp` column. Let's investigate column types in a couple of different ways:

```{r}
class(bhnut)
class(bhnut$date_time_stamp)
# the $ is a way to specify a single column in base R
# you can investigate, create, and remove columns with it

class(dat_nut)
class(dat_nut$datetimestamp)
```

The `glimpse()` function from the `dplyr` package gives an overview of all columns:

```{r}
glimpse(bhnut)
glimpse(dat_nut)
```

## General summaries

And there are some different ways to see summaries:

```{r}
skim(dat_nut)  # from the skimr package
summary(dat_nut)  # I almost never use this function anymore
```

### Overall -

-   `glimpse()` (from `dplyr`) is a function I use ALL. THE. TIME.\
-   so is `names()`\
-   `skim()` (from `skimr`) is great for a big-picture view of the dataset.

## Basic plots

Loooook at the data! Base R's `plot()` function is great for initial data exploration.  

```{r}
plot(sal ~ datetimestamp, data = dat_wq)
# let's talk about these weird values
# metadata is a beautiful thing

plot(temp ~ datetimestamp, data = dat_wq)

# make it a line plot instead of points
plot(temp ~ datetimestamp, data = dat_wq,
     type = "l")

# make the line blue and add nice axis labels and a title
plot(temp ~ datetimestamp, data = dat_wq,
     type = "l", col = "blue",
     xlab = "Date",
     ylab = "Water Temperature (C)",
     main = paste("Temp at", stn_wq))

# can make other varieties of plot too  
hist(dat_wq$temp)

# change some options
hist(dat_wq$temp,
     breaks = 30,
     col = "cadetblue3",
     xlab = "Water Temperature (C)",
     ylab = "Count",
     main = paste("Distribution of temp at", stn_wq))
```

## Subsetting and Pairs Plots

You can make a scatterplot matrix with a couple different base R functions. They get unhappy if you try to include non-numeric columns, so we will subset our data frame first. The easiest way to select columns is using the `select()` function from the `dplyr` package (part of the tidyverse).

For more information on how to subset in both base R and the tidyverse, check out presentations [`02_poking_and_prodding`](https://github.com/swmpkim/2022_infrequentUseR_wrangling/blob/main/slides/02_poking_and_prodding.pdf) and [`03_modifying_and_adding`](https://github.com/swmpkim/2022_infrequentUseR_wrangling/blob/main/slides/03_modifying_and_adding.pdf) from this '[Data Wrangling for the Infrequent UseR](https://github.com/swmpkim/2022_infrequentUseR_wrangling)' workshop.

```{r}
# what are our columns again?
names(dat_wq)
wq_numeric <- dat_wq |> 
    select(datetimestamp, temp, spcond, sal, do_pct)

# only a small amount of rows because my computer
# got really bogged down with the whole dataset

# here's a way to choose rows based on numeric position in base R -
# we are using only the first 1000
pairs(wq_numeric[1:1000, ])
```

We haven't dealt with those wacky salinity values yet - and will use `SWMPr::qaqc()` a little later - but for now, let's subset the data to only keep the salinity values that are in a realistic range. We will also use `dplyr` here; the `filter()` function.

Those values occurred in 2019, so we'll filter the data to around that time.

```{r}
wq_2019 <- wq_numeric |> 
    filter(datetimestamp >= "2019-04-01 00:00",
           datetimestamp <= "2019-04-30 23:45")

# did we get the wild values?
skim(wq_2019)

# let's also make a data frame without those
wq_2019_salOK <- wq_2019 |> 
    filter(sal < 35,
           sal >= 0)

# and do pairs plots of each
pairs(wq_2019)
pairs(wq_2019_salOK)
```

### Sidebar - turning things into dates

```{r}
#| eval: false

# notice: if you try to make a time series plot
# on the bhnut data frame, where date is a character
# it doesn't go well

# shoot, what are the names again?
names(bhnut)

# try to plot it
plot(chla_n ~ date_time_stamp, data = bhnut)
```

We can turn things into dates fairly easily using the `lubridate` package. More information [online](https://lubridate.tidyverse.org/).

```{r}
bhnut$date_time_stamp <- lubridate::mdy_hm(bhnut$date_time_stamp)
glimpse(bhnut)
```

Now we can make a plot:

```{r}
plot(chla_n ~ date_time_stamp, data = bhnut)
```

We can also pull out parts of dates, for example if we wanted to make a boxplot of chla values by year:

```{r}
dat_nut$year <- lubridate::year(dat_nut$datetimestamp)

# make sure that worked
glimpse(dat_nut)

# now boxplot
boxplot(chla_n ~ year, data = dat_nut)

# dress it up
boxplot(chla_n ~ year, data = dat_nut,
        col = "lightgreen",
        main = paste("Chl a at", stn_nut),
        xlab = "Year",
        ylab = "Chl a (ug/L)")

# remove year again because for some reason it causes problems
# in the cens_id function
dat_nut$year <- NULL

# tidyverse way to remove a column would be:
# dat_nut <- dat_nut |> 
#     select(-year)
```

# Your turn 1

Use your favorite methods from above to investigate the `dat_wq` and `dat_met` data frames.

```{r}

```

------------------------------------------------------------------------

------------------------------------------------------------------------

# QA/QC flags and codes

`SWMPr` has powerful functionality when it comes to QA/QC flags and codes.

## Which flags and codes are present?

```{r}
qaqcchk(dat_nut)
```

## Which values are flagged as \<MDL?

Sometimes we need to know when values are censored (below detection). The `cens_id()` function in `SWMPr` will tell us, at least with the modern (2007 and later) qa/qc codes, by identifying rows where the flag column contains "-4" or "-5".

Note, this function needs to be used before the `qaqc()` function because the latter removes the flag columns.

```{r}
head(cens_id(dat_nut))

dat_nut <- cens_id(dat_nut, flag_type = "below") # note I only need true/false for below the MDL, not -1/0/1 like above- default was
# checking for both above and below detection

# see how that looks now
glimpse(dat_nut)
```

## Using QA/QC flags to remove 'bad' values

```{r}
# what are we dealing with, again?
qaqcchk(dat_nut)

# I'm okay keeping those 1s, in addition to 0 and -4
qc_nut <- qaqc(dat_nut, qaqc_keep = c("0", "1", "-4"))

# see what that did  
glimpse(qc_nut)
class(qc_nut)

# and do it for wq and met
qc_wq <- qaqc(dat_wq, qaqc_keep = c("0", "1"))
qc_met <- qaqc(dat_met, qaqc_keep = c("0", "1"))
```

Make sure that got rid of those wacky salinity values:

```{r}
plot(sal ~ datetimestamp, data = qc_wq)
```

# Summarizing data

Let's say you want monthly averages for your parameters.

## With `SWMPr`

```{r}
monthly_wq <- aggreswmp(qc_wq, by = "months")
glimpse(monthly_wq)
# notice how datetimestamp is represented now -
# R does not have a "year-month" class
# so the typical way to deal with monthly data is to tack on -01
# to represent the first day of each month

plot(sal ~ datetimestamp, data = monthly_wq, type = "b",
     main = "mean monthly salinity")
```

The defaults for `aggreswmp` are to run on every parameter, calculating the mean with any NAs removed. You can change that if you want, to (e.g.) monthly maxima:

```{r}
mmax_wq <- aggreswmp(qc_wq, by = "months",
                     FUN = max)
glimpse(mmax_wq)

# note, that didn't remove NAs
# but we can, with just a comma
mmax_wq <- aggreswmp(qc_wq, by = "months",
                     FUN = max, na.rm = TRUE)
glimpse(mmax_wq)


plot(sal ~ datetimestamp, data = mmax_wq, type = "b",
     main = "max monthly salinity")
```

Note, we can put both those lines on the same plot, and we will with `ggplot2`. But first, more `aggreswmp`.

### Totals

We're not necessarily interested in average precipitation within a month; we want to know the total! Sometimes even by day! SWMPr does that too.

```{r}
daily_rain <- aggreswmp(qc_met, by = "days", params = "totprcp",
                        FUN = sum, na.rm = TRUE)
monthly_rain <- aggreswmp(qc_met, by = "months", params = "totprcp",
                        FUN = sum, na.rm = TRUE)


barplot(totprcp ~ datetimestamp, data = monthly_rain,
        col = "navyblue",
        main = paste("Total Monthly Precip at", stn_met),
        xlab = "Month",
        ylab = "Precip (mm)",
        xaxt = "n")
```

## With the tidyverse

What `aggreswmp` did for us was group each month together, and then calculate the summary we told it to. We'll have to do that extra step of defining months before we can summarize with the tidyverse. This method is nice because you can use it on non-SWMP datasets, and you can use more than a single function on each parameter (e.g. we might want min, mean, and max values for each month).  

We're going to pick up a couple of new skills here too, particularly use of the pipe.

### Pick a couple of parameters  

We are using the `zoo` package to create a "year-month" format from our datetimestamp column - like what SWMPr did for us, but it's displayed a little more nicely. We are also using some functions from the `dplyr` package (part of the tidyverse) to actually add that column, then summarize other columns by year-month.  

```{r}
monthly_wq2 <- qc_wq |> 
    mutate(month = as.yearmon(datetimestamp)) |>   # mutate will add or modify columns
    summarize(.by = month,
              mean_sal = mean(sal, na.rm = TRUE),
              max_sal = max(sal, na.rm = TRUE),
              mean_temp = mean(temp, na.rm = TRUE),
              max_temp = max(temp, na.rm = TRUE))
glimpse(monthly_wq2)


plot(mean_sal ~ month, data = monthly_wq2, type = "b",
     main = "mean monthly salinity")
```


### A note on summarizing with the tidyverse  

Here's something that's changed though - using the tidyverse on a swmpr data frame removes the "SWMPr-ness" of the data frame:

```{r}
class(monthly_wq) # used aggreswmp
class(monthly_wq2) # used tidyverse
```

What this means is, we can't directly use more SWMPr functions on the one where we used the tidyverse. THIS IS OKAY - I generally don't worry about it because I'm not using SWMPr capabilities once I've started in on grouped summaries or fancier things.  

But if you want to use some additional SWMPr or SWMPrExtension functionality, you can turn it back into a swmpr object with the `swmpr()` function.

```{r}
# attributes are like metadata of a data frame
attributes(monthly_wq)
attributes(monthly_wq2)

# turn it back into a swmpr object
monthly_wq2 <- swmpr(monthly_wq2, meta_in = stn_wq)
# if I weren't trying to be flexible, this would look like
# mmax_wq2 <- swmpr(mmax_wq2, meta_in = "gndbhwq")


# check the class
class(monthly_wq2)

# check the attributes now
attributes(monthly_wq2)
```



# `ggplot2` intro   

`ggplot2` is a phenomenal graphing package. We don't have time here to get into all of the nuances, but we will make a few plots with the following code. The [Data visualization](https://r4ds.hadley.nz/data-visualize) chapter of [R for Data Science](https://r4ds.hadley.nz/) is a great introductory resource for learning how these pieces get put together; and [Chapter 9 (Layers)](https://r4ds.hadley.nz/layers) goes through more powerful options, including facets and smooths. [Chapter 11 (Communication)](https://r4ds.hadley.nz/communication) touches on ways to make the graphs more attractive by modifying labels, annotations, legends, and the general body of the plot.

The `esquisse` package can get you started assembling ggplots in a point-and-click way, and `ggThemeAssist` can help with beautifying. You installed both packages before the workshop and can get to them from the "Addins" drop-down under the main toolbar.

## Building a line graph  

Here, we are going to make a graph that includes lines for our monthly mean and max salinity values. We will construct it in a few different ways and start learning about the different ways to layer information together.  

Note in this code chunk, we also see how to assign labels to the graph - title, subtitle, and x- and y-axis labels. 

```{r}
# if we want to put points and lines on the graph to represent the same
# data, we can put all of the identifying information in the top line
ggplot(monthly_wq2, aes(x = month, y = mean_sal)) +
    geom_point() +
    geom_line() +
    labs(title = "mean monthly salinity",
         subtitle = paste("at", stn_wq),
         x = "Month",
         y = "Salinity (psu)")
```

### Multiple lines  

We can put multiple lines onto the same plot by adding another `geom_line()` layer.  

```{r}
# anything that will be different between groups can go in the layer itself - we could keep aes(x = month) in the top line, but
# personally I prefer to always specify x and y together
# so I only keep the data in the top line

ggplot(monthly_wq2) +
    geom_line(aes(x = month, y = mean_sal)) +
    geom_line(aes(x = month, y = max_sal))
```

### Colors  

We can specify colors for the lines.  

```{r}
ggplot(monthly_wq2) +
    geom_line(aes(x = month, y = mean_sal), 
              col = "blue") +
    geom_line(aes(x = month, y = max_sal), 
              col = "darkorange")
```

Even better, we can let `ggplot` assign colors based on values in the data - and it will automatically create a legend! Here, `col` goes *inside* the `aes()` argument.  

```{r}
ggplot(monthly_wq2) +
    geom_line(aes(x = month, y = mean_sal, 
                  col = "mean")) +
    geom_line(aes(x = month, y = max_sal,
                  col = "max"))
```



Another nice thing about defining colors inside `aes()` is, you can let it assign those colors based on actual data values - for example, censored or non-censored!  


```{r}
ggplot(dat_nut, aes(x = datetimestamp, 
                    y = po4f, 
                    col = c_po4f)) +
    geom_point(size = 2) +
    labs(col = "PO4 below detection?")
```



If you don't like the default colors, you can change them - `scale_color_brewer()` is a good layer to play around with (it's built into `ggplot2` and you can view palettes on https://colorbrewer2.org/). I also quite like the `khroma` package for colorblind-friendly palettes; website: https://packages.tesselle.org/khroma/ .  

```{r}
# use a different color palette - e.g. from RColorBrewer
ggplot(monthly_wq2) +
    geom_line(aes(x = month, y = mean_sal, 
                  col = "mean")) +
    geom_line(aes(x = month, y = max_sal,
                  col = "max")) +
    scale_color_brewer(palette = "Set1")
```


## Different data frames  

We can even use data from different data frames. Suppose you have been working with 2 or 3 stations and want the mean monthly salinity of all of them on the same graph.  


For our example, we'll simply use mean and max salinity out of the different data frames we calculated above.
When you do this, you have to specify the data in each line, not at the top of the call.

```{r}
ggplot() +
    geom_line(data = monthly_wq, 
              aes(x = datetimestamp, y = sal,
                  col = "mean"),
              linewidth = 0.8) +
    geom_line(data = mmax_wq, 
              aes(x = datetimestamp, y = sal,
                  col = "max"),
              linewidth = 0.8)
```

## Facets  

Facets are different panels in the graph, based on some category in the data. For example, we might want to see if the relationship between two variables varies by month or year.  

```{r}
# first we have to make a year column
monthly_wq2 <- monthly_wq2 |> 
    mutate(year = lubridate::year(month))

ggplot(monthly_wq2, 
       aes(x = mean_sal, y = mean_temp, col = year)) +
    geom_point(size = 3) +
    facet_wrap(~year) 

```



## Plot as object  

```{r}
# you can also save a plot as an object, then add to it in different ways
# I do this a LOT when playing with color options
p <- ggplot(monthly_wq2) +
    geom_line(aes(x = month, y = mean_sal, 
                  col = "mean")) +
    geom_line(aes(x = month, y = max_sal,
                  col = "max"))

p

p <- p +
    labs(title = paste("Salinity at", stn_wq),
         x = "Month",
         y = "Salinity (psu)",
         col = "monthly value")

p

p + 
    scale_color_brewer(palette = "Set1")

p +
    theme_bw()

p <- p +
    scale_color_brewer(palette = "Set1") +
    theme_bw()

p
```


# More SWMPr and SWMPrExtension functionality

## SWMPr

If you are using your own data, you'll need to change the years that appear in the code below.

```{r}
# make a plot like the SWMPrats widget
plot_summary(qc_wq, param = 'sal')

# make a wind rose
plot_wind(qc_met)
plot_wind(qc_met, type = "season")
plot_wind(qc_met, type = "season", years = 2018:2020)

# one year over historical data
plot_quants(qc_wq, param = 'temp',
            yr = 2020,
            yrstart = 2018,
            yrend = 2019)
```

## SWMPrExtension

```{r}
library(SWMPrExtension)
```

```{r}
# similar to the last of the above
historical_daily_range(qc_wq, param = 'temp',
                       target_yr = 2020)

# monthly ranges
historical_range(qc_wq, param = 'temp',
                 target_yr = 2020,
                 hist_rng = c(2018, 2019))
# can also include a threshold
historical_range(qc_wq, param = 'temp',
                 target_yr = 2020,
                 hist_rng = c(2018, 2019),
                 criteria = 25)

# seasonal boxplot
seasonal_boxplot(qc_wq, param = 'temp')

# can add a target year to see how it compares
seasonal_boxplot(qc_wq, param = 'temp',
                 target_yr = 2020)

# precip!
seasonal_barplot(qc_met, param = 'totprcp')

# assign seasons
seasonal_barplot(qc_met, param = 'totprcp',
                 season_grps = list(c(1,2,3), c(4,5,6), c(7,8,9), c(10, 11, 12)),
                 season_names = c('Winter', 'Spring', 'Summer', 'Fall'))
```
